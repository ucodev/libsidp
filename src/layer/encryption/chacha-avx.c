/**
 * @file chacha_avx.c
 * @brief SIDP Encryption Layer - ChaCha-avx Encrypt/Decrypt Interface
 */

/*
   Secure Inter-Device Protocol Library

   Copyright 2012-2014 Pedro A. Hortas (pah@ucodev.org)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* XXX: Get rid of openssl from chacha-avx code asap */
#include <openssl/evp.h>
#include <openssl/rand.h>


#include <chacha-avx/chacha-avx.h>
#include <nacl/crypto_onetimeauth.h>


#include "el_chacha_avx.h"


/**
 * @brief ChaCha-AVX Initialization function.
 * @return 0 on success, -1 on error.
 */
int el_chacha_avx_init(void) {
	/* Nothing to do */
	return 0;
}

/**
 * @brief ChaCha-AVX Create Key function
 * @see el_chacha_avx_encrypt_data()
 * @see el_chacha_avx_decrypt_data()
 * @param key_data The data that will be used to create the key (eg. user+pass)
 * @param key The key generated, based on key_data value
 * @return 0 on success, -1 on error.
 */
int el_chacha_avx_create_key(const unsigned char *key_data, unsigned char *key) {
	int ret, nrounds = 5;
	unsigned char iv[32];

	/* XXX: Get rid of openssl from chacha_avx code asap */
	ret = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha256(), NULL, key_data, strlen((char *) key_data), nrounds, key, iv);

	return -(ret != 32);
}

/**
 * @brief ChaCha-AVX encrypted data size
 * @see el_chacha_avx_decrypt_output_len()
 * @param plain_data_len The size of the plain-text data
 * @return The required size for the 'out' param of the
 * el_chacha_avx_encrypt_data() function.
 */
size_t el_chacha_avx_encrypt_output_len(size_t plain_data_len) {
	return plain_data_len + CHACHA_AVX_CRYPTO_NONCEBYTES + crypto_onetimeauth_KEYBYTES;
}

/**
 * @brief ChaCha-AVX decrypted data size
 * @see el_chacha_avx_encrypt_output_len()
 * @param enc_data_len The size of encrypted data
 * @return The required size for the 'out' param of the
 * el_chacha_avx_decrypt_data() function.
 */
size_t el_chacha_avx_decrypt_output_len(size_t enc_data_len) {
	return enc_data_len - (CHACHA_AVX_CRYPTO_NONCEBYTES + crypto_onetimeauth_KEYBYTES);
}

/**
 * @brief ChaCha-AVX data encryption
 * @see el_chacha_avx_create_key()
 * @see el_chacha_avx_decrypt_data()
 * @param key The key generated by el_chacha_avx_create_key()
 * @param out Output buffer containing the encrypted data
 * @param in Input buffer containing the plain-text data
 * @param in_len The size of the plain-text data buffer
 * @return The size of encrypted data buffer (output) or -1 on error
 */
int el_chacha_avx_encrypt_data(
		const unsigned char *key,
		unsigned char *out,
		const unsigned char *in,
		size_t in_len) {
	unsigned char a[crypto_onetimeauth_KEYBYTES];
	unsigned char n[CHACHA_AVX_CRYPTO_NONCEBYTES];

	/* XXX: Get rid of openssl from chacha_avx code asap */
	if (!RAND_bytes(n, CHACHA_AVX_CRYPTO_NONCEBYTES))
		return -1;

	if (chacha_avx_crypto_stream_xor(out + CHACHA_AVX_CRYPTO_NONCEBYTES + crypto_onetimeauth_KEYBYTES, in, in_len, n, key) < 0)
		return -2;

	if (crypto_onetimeauth(a, out + CHACHA_AVX_CRYPTO_NONCEBYTES + crypto_onetimeauth_KEYBYTES, in_len, key) < 0)
		return -3;

	memcpy(out, n, CHACHA_AVX_CRYPTO_NONCEBYTES);
	memcpy(out + CHACHA_AVX_CRYPTO_NONCEBYTES, a, crypto_onetimeauth_KEYBYTES);

	return in_len + CHACHA_AVX_CRYPTO_NONCEBYTES + crypto_onetimeauth_KEYBYTES;
}

/**
 * @brief ChaCha-AVX data decryption
 * @see el_chacha_avx_create_key()
 * @see el_chacha_avx_encrypt_data()
 * @param key The key generated by el_chacha_avx_create_key()
 * @param out Output buffer containing the decrypted data
 * @param in Input buffer containing the encrypted data
 * @param in_len The size of encrypted data buffer
 * @return The size of decrypted data buffer (output) or -1 on error
 */
int el_chacha_avx_decrypt_data(
		const unsigned char *key,
		unsigned char *out,
		const unsigned char *in,
		size_t in_len) {
	unsigned char a[crypto_onetimeauth_KEYBYTES];
	unsigned char n[CHACHA_AVX_CRYPTO_NONCEBYTES];

	memcpy(n, in, CHACHA_AVX_CRYPTO_NONCEBYTES);
	memcpy(a, in + CHACHA_AVX_CRYPTO_NONCEBYTES, crypto_onetimeauth_KEYBYTES);

	if (crypto_onetimeauth_verify(a, in + CHACHA_AVX_CRYPTO_NONCEBYTES + crypto_onetimeauth_KEYBYTES, in_len - CHACHA_AVX_CRYPTO_NONCEBYTES - crypto_onetimeauth_KEYBYTES, key) < 0)
		return -1;

	if (chacha_avx_crypto_stream_xor(out, in + CHACHA_AVX_CRYPTO_NONCEBYTES + crypto_onetimeauth_KEYBYTES, in_len - CHACHA_AVX_CRYPTO_NONCEBYTES - crypto_onetimeauth_KEYBYTES, n, key) < 0)
		return -2;

	return in_len - CHACHA_AVX_CRYPTO_NONCEBYTES - crypto_onetimeauth_KEYBYTES;
}

