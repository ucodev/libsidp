/**
 * @file xsalsa20.c
 * @brief SIDP Encryption Layer - XSalsa20 Encrypt/Decrypt Interface
 */

/*
   Secure Inter-Device Protocol Library

   Copyright 2012-2014 Pedro A. Hortas (pah@ucodev.org)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* XXX: Get rid of openssl from xsalsa20 code asap */
#include <openssl/evp.h>
#include <openssl/rand.h>


#include <nacl/crypto_stream.h>
#include <nacl/crypto_onetimeauth.h>

#include "el_xsalsa20.h"


/**
 * @brief XSalsa20 Initialization function.
 * @return 0 on success, -1 on error.
 */
int el_xsalsa20_init(void) {
	/* Nothing to do */
	return 0;
}

/**
 * @brief XSalsa20 Create Key function
 * @see el_xsalsa20_encrypt_data()
 * @see el_xsalsa20_decrypt_data()
 * @param key_data The data that will be used to create the key (eg. user+pass)
 * @param key The key generated, based on key_data value
 * @return 0 on success, -1 on error.
 */
int el_xsalsa20_create_key(const unsigned char *key_data, unsigned char *key) {
	int ret, nrounds = 5;
	unsigned char iv[32];

	/* XXX: Get rid of openssl from xsalsa20 code asap */
	ret = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha256(), NULL, key_data, strlen((char *) key_data), nrounds, key, iv);

	return -(ret != 32);
}

/**
 * @brief XSalsa20 encrypted data size
 * @see el_xsalsa20_decrypt_output_len()
 * @param plain_data_len The size of the plain-text data
 * @return The required size for the 'out' param of the
 * el_xsalsa20_encrypt_data() function.
 */
size_t el_xsalsa20_encrypt_output_len(size_t plain_data_len) {
	return plain_data_len + crypto_stream_NONCEBYTES + crypto_onetimeauth_KEYBYTES;
}

/**
 * @brief XSalsa20 decrypted data size
 * @see el_xsalsa20_encrypt_output_len()
 * @param enc_data_len The size of encrypted data
 * @return The required size for the 'out' param of the
 * el_xsalsa20_decrypt_data() function.
 */
size_t el_xsalsa20_decrypt_output_len(size_t enc_data_len) {
	return enc_data_len - (crypto_stream_NONCEBYTES + crypto_onetimeauth_KEYBYTES);
}

/**
 * @brief XSalsa20 data encryption
 * @see el_xsalsa20_create_key()
 * @see el_xsalsa20_decrypt_data()
 * @param key The key generated by el_xsalsa20_create_key()
 * @param out Output buffer containing the encrypted data
 * @param in Input buffer containing the plain-text data
 * @param in_len The size of the plain-text data buffer
 * @return The size of encrypted data buffer (output) or -1 on error
 */
int el_xsalsa20_encrypt_data(
		const unsigned char *key,
		unsigned char *out,
		const unsigned char *in,
		size_t in_len) {
	unsigned char a[crypto_onetimeauth_KEYBYTES];
	unsigned char n[crypto_stream_NONCEBYTES];

	/* XXX: Get rid of openssl from xsalsa20 code asap */
	if (!RAND_bytes(n, crypto_stream_NONCEBYTES))
		return -1;

	if (crypto_stream_xor(out + crypto_stream_NONCEBYTES + crypto_onetimeauth_KEYBYTES, in, in_len, n, key) < 0)
		return -2;

	if (crypto_onetimeauth(a, out + crypto_stream_NONCEBYTES + crypto_onetimeauth_KEYBYTES, in_len, key) < 0)
		return -3;

	memcpy(out, n, crypto_stream_NONCEBYTES);
	memcpy(out + crypto_stream_NONCEBYTES, a, crypto_onetimeauth_KEYBYTES);

	return in_len + crypto_stream_NONCEBYTES + crypto_onetimeauth_KEYBYTES;
}

/**
 * @brief XSalsa20 data decryption
 * @see el_xsalsa20_create_key()
 * @see el_xsalsa20_encrypt_data()
 * @param key The key generated by el_xsalsa20_create_key()
 * @param out Output buffer containing the decrypted data
 * @param in Input buffer containing the encrypted data
 * @param in_len The size of encrypted data buffer
 * @return The size of decrypted data buffer (output) or -1 on error
 */
int el_xsalsa20_decrypt_data(
		const unsigned char *key,
		unsigned char *out,
		const unsigned char *in,
		size_t in_len) {
	unsigned char a[crypto_onetimeauth_KEYBYTES];
	unsigned char n[crypto_stream_NONCEBYTES];

	memcpy(n, in, crypto_stream_NONCEBYTES);
	memcpy(a, in + crypto_stream_NONCEBYTES, crypto_onetimeauth_KEYBYTES);

	if (crypto_onetimeauth_verify(a, in + crypto_stream_NONCEBYTES + crypto_onetimeauth_KEYBYTES, in_len - crypto_stream_NONCEBYTES - crypto_onetimeauth_KEYBYTES, key) < 0)
		return -1;

	if (crypto_stream_xor(out, in + crypto_stream_NONCEBYTES + crypto_onetimeauth_KEYBYTES, in_len - crypto_stream_NONCEBYTES - crypto_onetimeauth_KEYBYTES, n, key) < 0)
		return -2;

	return in_len - crypto_stream_NONCEBYTES - crypto_onetimeauth_KEYBYTES;
}

