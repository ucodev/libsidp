/**
 * @file aes256cbc.c
 * @brief SIDP Encryption Layer - AES256 Encrypt/Decrypt Interface
 */

/*
   Secure Inter-Device Protocol Library

   Copyright 2012-2014 Pedro A. Hortas (pah@ucodev.org)

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/evp.h>
#include <openssl/hmac.h>
#include <openssl/rand.h>

#include "el_aes256cbc.h"

/**
 * @brief AES256 Initialization function.
 * @return 0 on success, -1 on error.
 */
int el_aes256_init(void) {
	/* Nothing to do */
	return 0;
}

/**
 * @brief AES256 Create Key function
 * @see el_aes256_encrypt_data()
 * @see el_aes256_decrypt_data()
 * @param key_data The data that will be used to create the key (eg. user+pass)
 * @param key The key generated, based on key_data value
 * @return 0 on success, -1 on error.
 */
int el_aes256_create_key(const unsigned char *key_data, unsigned char *key) {
	int ret, nrounds = 5;
	unsigned char iv[32];

	ret = EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha256(), NULL, key_data, strlen((char *) key_data), nrounds, key, iv);

	return -(ret != 32);
}

/**
 * @brief AES256 encrypted data size
 * @see el_aes256_decrypt_output_len()
 * @param plain_data_len The size of the plain-text data
 * @return The required size for the 'out' param of the el_aes256_encrypt_data()
 * function.
 */
size_t el_aes256_encrypt_output_len(size_t plain_data_len) {
	return (plain_data_len | 0xf) + 1 + EVP_MAX_MD_SIZE + EVP_MAX_IV_LENGTH;
}

/**
 * @brief AES256 decrypted data size
 * @see el_aes256_encrypt_output_len()
 * @param enc_data_len The size of encrypted data
 * @return The required size for the 'out' param of the el_aes256_decrypt_data()
 * function
 */
size_t el_aes256_decrypt_output_len(size_t enc_data_len) {
	return enc_data_len;
}

/**
 * @brief AES256 data encryption
 * @see el_aes256_create_key()
 * @see el_aes256_decrypt_data()
 * @param key The key generated by el_aes256_create_key()
 * @param out Output buffer containing the encrypted data
 * @param in Input buffer containing the plain-text data
 * @param in_len The size of the plain-text data buffer
 * @return The size of encrypted data buffer (output) or -1 on error
 */
int el_aes256_encrypt_data(
		const unsigned char *key,
		unsigned char *out,
		const unsigned char *in,
		size_t in_len) {
	EVP_CIPHER_CTX e_ctx;
	unsigned int mdlen;
	int clen, flen;
	
	unsigned char *iv = out + EVP_MAX_MD_SIZE;
	unsigned char *enctext = out + EVP_MAX_MD_SIZE + EVP_MAX_IV_LENGTH;
	
	/* Just in case */
	memset(out, 0, EVP_MAX_MD_SIZE + EVP_MAX_IV_LENGTH);

	if (!RAND_bytes(iv, EVP_MAX_IV_LENGTH))
		return -1;

	EVP_CIPHER_CTX_init(&e_ctx);

	if (!EVP_EncryptInit_ex(&e_ctx, EVP_aes_256_cbc(), NULL, key, iv)) {
		EVP_CIPHER_CTX_cleanup(&e_ctx);
		return -2;
	}

	if (!EVP_EncryptUpdate(&e_ctx, enctext, &clen, in, in_len)) {
		EVP_CIPHER_CTX_cleanup(&e_ctx);
		return -3;
	}

	if (!EVP_EncryptFinal_ex(&e_ctx, enctext + clen, &flen)) {
		EVP_CIPHER_CTX_cleanup(&e_ctx);
		return -4;
	}

	EVP_CIPHER_CTX_cleanup(&e_ctx);

	clen += flen;

	if (!HMAC(EVP_sha256(), key, EVP_MAX_KEY_LENGTH, out + EVP_MAX_MD_SIZE, clen + EVP_MAX_IV_LENGTH, out, &mdlen))
		return -5;

	return clen + EVP_MAX_MD_SIZE + EVP_MAX_IV_LENGTH;
}

/**
 * @brief AES256 data decryption
 * @see el_aes256_create_key()
 * @see el_aes256_encrypt_data()
 * @param key The key generated by el_aes256_create_key()
 * @param out Output buffer containing the decrypted data
 * @param in Input buffer containing the encrypted data
 * @param in_len The size of encrypted data buffer
 * @return The size of decrypted data buffer (output) or -1 on error
 */
int el_aes256_decrypt_data(
		const unsigned char *key,
		unsigned char *out,
		const unsigned char *in,
		size_t in_len) {
	EVP_CIPHER_CTX e_ctx;
	unsigned char hmac[EVP_MAX_MD_SIZE];
	unsigned int mdlen;
	int mlen, flen;
	
	const unsigned char *enctext = in + EVP_MAX_MD_SIZE + EVP_MAX_IV_LENGTH;
	const unsigned char *iv = in + EVP_MAX_MD_SIZE;

	if (!HMAC(EVP_sha256(), key, EVP_MAX_KEY_LENGTH, in + EVP_MAX_MD_SIZE, in_len - EVP_MAX_MD_SIZE, hmac, &mdlen))
		return -1;

	/* Switch to constant-time comparison function */
	if (memcmp(in, hmac, mdlen))
		return -2;

	EVP_CIPHER_CTX_init(&e_ctx);

	if (!EVP_DecryptInit_ex(&e_ctx, EVP_aes_256_cbc(), NULL, key, iv)) {
		EVP_CIPHER_CTX_cleanup(&e_ctx);
		return -3;
	}

	if (!EVP_DecryptUpdate(&e_ctx, out, &mlen, enctext, in_len - EVP_MAX_MD_SIZE - EVP_MAX_IV_LENGTH)) {
		EVP_CIPHER_CTX_cleanup(&e_ctx);
		return -4;
	}

	EVP_DecryptFinal_ex(&e_ctx, out + mlen, &flen);

	EVP_CIPHER_CTX_cleanup(&e_ctx);

	return mlen + flen;
}

